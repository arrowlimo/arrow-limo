#!/usr/bin/env python3
"""
Fix driver_payroll driver/employee mismatches for 2021-2024 using the audit CSV.
Safety features:
- Creates a timestamped backup table containing all rows to be modified
- Writes an audit log table (payroll_fix_audit) for every change
- Dry-run by default; requires --apply to write

Inputs:
- exports/driver_audit/mismatches_2021_2024.csv generated by audit_charter_vs_payroll_2021_2024.py

Behavior:
- For each mismatch row, sets driver_payroll.employee_id to charter.assigned_driver_id
- If possible, sets driver_payroll.driver_id to employees.employee_number for that employee
- Skips when assigned_driver_id is NULL

Outputs:
- Prints summary counts
- Creates audit table and backup table when applying
"""

import csv
import argparse
from pathlib import Path
from datetime import datetime
import psycopg2

DB = dict(dbname='almsdata', user='postgres', password='***REDACTED***', host='localhost')
MISMATCH_CSV = Path(__file__).parent.parent / 'exports' / 'driver_audit' / 'mismatches_2021_2024.csv'


def connect():
    return psycopg2.connect(**DB)


def ensure_audit_table(cur):
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS payroll_fix_audit (
            id SERIAL PRIMARY KEY,
            driver_payroll_id INTEGER NOT NULL,
            charter_id INTEGER,
            reserve_number VARCHAR(50),
            old_employee_id INTEGER,
            old_driver_id VARCHAR(50),
            new_employee_id INTEGER,
            new_driver_id VARCHAR(50),
            reason VARCHAR(200),
            fixed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
        """
    )


def get_employee_number(cur, employee_id):
    cur.execute("SELECT employee_number FROM employees WHERE employee_id = %s", (employee_id,))
    row = cur.fetchone()
    return row[0] if row and row[0] is not None else None


def gather_row_ids(to_fix):
    return [r['payroll_entry_id'] for r in to_fix]


def create_backup_table(cur, ids):
    ts = datetime.now().strftime('%Y%m%d_%H%M%S')
    bname = f"driver_payroll_backup_{ts}"
    cur.execute(f"CREATE TABLE {bname} AS SELECT * FROM driver_payroll WHERE id = ANY(%s)", (ids,))
    return bname


def load_mismatches(limit=None):
    rows = []
    if not MISMATCH_CSV.exists():
        raise FileNotFoundError(f"Mismatch file not found: {MISMATCH_CSV}")
    with open(MISMATCH_CSV, 'r', encoding='utf-8') as f:
        r = csv.DictReader(f)
        for row in r:
            rows.append({
                'charter_id': int(row['charter_id']),
                'reserve_number': row['reserve_number'],
                'assigned_driver_id': int(row['assigned_driver_id']) if row['assigned_driver_id'] else None,
                'payroll_entry_id': int(row['payroll_entry_id']),
                'payroll_driver_id': row['payroll_driver_id'] or None,
                'payroll_employee_id': int(row['payroll_employee_id']) if row['payroll_employee_id'] else None
            })
            if limit and len(rows) >= limit:
                break
    return rows


def fix_mismatches(apply=False, limit=None):
    to_fix = load_mismatches(limit=limit)
    if not to_fix:
        print("No mismatches found to fix.")
        return

    # Filter out rows without a known assigned_driver_id
    candidates = [r for r in to_fix if r['assigned_driver_id'] is not None]

    print(f"Loaded mismatches: {len(to_fix):,}; candidates with assigned driver: {len(candidates):,}")

    conn = connect()
    cur = conn.cursor()

    # Stats
    fixed = 0
    skipped = 0

    # Backup + audit table only if applying
    backup_table = None
    if apply:
        ensure_audit_table(cur)
        ids = gather_row_ids(candidates)
        backup_table = create_backup_table(cur, ids)
        print(f"Backup created: {backup_table} (rows: {len(ids):,})")

    for r in candidates:
        # Load current payroll row
        cur.execute("SELECT employee_id, driver_id FROM driver_payroll WHERE id = %s", (r['payroll_entry_id'],))
        row = cur.fetchone()
        if not row:
            skipped += 1
            continue
        old_emp_id, old_driver_id = row[0], row[1]
        new_emp_id = r['assigned_driver_id']
        new_driver_id = None

        # Resolve employee_number for the assigned driver
        new_driver_id = get_employee_number(cur, new_emp_id)

        # Decide if change is needed
        needs_change = (old_emp_id != new_emp_id) or (new_driver_id is not None and old_driver_id != new_driver_id)
        if not needs_change:
            skipped += 1
            continue

        if apply:
            try:
                cur.execute(
                    "UPDATE driver_payroll SET employee_id = %s, driver_id = %s WHERE id = %s",
                    (new_emp_id, new_driver_id, r['payroll_entry_id'])
                )
                cur.execute(
                    "INSERT INTO payroll_fix_audit (driver_payroll_id, charter_id, reserve_number, old_employee_id, old_driver_id, new_employee_id, new_driver_id, reason) VALUES (%s,%s,%s,%s,%s,%s,%s,%s)",
                    (r['payroll_entry_id'], r['charter_id'], r['reserve_number'], old_emp_id, old_driver_id, new_emp_id, new_driver_id, 'MATCH_CHARTER_ASSIGNED_DRIVER')
                )
                fixed += 1
            except Exception as e:
                conn.rollback()
                print(f"[WARN] Update failed for driver_payroll.id={r['payroll_entry_id']}: {e}")
                continue
        else:
            fixed += 1

    if apply:
        conn.commit()

    print("\nSUMMARY:")
    print(f"  Candidates: {len(candidates):,}")
    print(f"  Fixed:      {fixed:,}{' (applied)' if apply else ' (dry-run)'}")
    print(f"  Skipped:    {skipped:,}")

    cur.close(); conn.close()


def main():
    ap = argparse.ArgumentParser(description='Fix driver_payroll mismatches based on audit CSV (2021-2024).')
    ap.add_argument('--limit', type=int, help='Limit number of rows to process (for testing)')
    ap.add_argument('--apply', action='store_true', help='Apply changes (default is dry-run)')
    args = ap.parse_args()

    fix_mismatches(apply=args.apply, limit=args.limit)


if __name__ == '__main__':
    main()
